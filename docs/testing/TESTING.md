# TESTING

> **Purpose:** Explain why this project’s testing wiring exists, so future refactors don’t quietly break integration tests.

This project uses **Spring Boot 4**, **JUnit 5**, **Testcontainers**, **PostgreSQL**, and **Flyway**.

---

## The contract

All integration tests must run with a single command:

```bash
./gradlew test
```

They must behave identically:

- on a developer laptop (Docker Desktop or Colima)
- in CI
- without a manually installed PostgreSQL server
- without developers maintaining a local `pokedex_test` database

If tests ever require extra steps, the wiring has regressed.

CI depends on this contract being true.

---

## Why tests require Docker

This project intentionally runs integration tests against a real PostgreSQL
instance using **Testcontainers**.

This is a deliberate architectural decision to ensure production parity.

See:

- [ADR-001](../adr/ADR-001-database-postgresql.md): Use PostgreSQL across local, test, CI, and production
- [ADR-002](../adr/ADR-002-testcontainers.md): Use Testcontainers for PostgreSQL-backed integration tests

---

## Why Testcontainers (real PostgreSQL) instead of H2

We use Testcontainers + PostgreSQL to prevent “works in tests, fails in prod” issues:

- PostgreSQL SQL dialect and behavior (constraints, indexes, JSON types, enums, timestamps)
- Flyway migrations applied exactly as in production
- Connection pooling, transaction behavior, and isolation levels closer to reality

If you switch to an in-memory database for tests, you must accept that some production issues will only be caught after deployment.

---

## The key pattern: `BaseIntegrationTest`

Integration tests extend a shared base class:

- a **single** PostgreSQL container is started once per JVM test run
- Spring is pointed at that container via **`@DynamicPropertySource`**
- Flyway runs migrations against the container on startup

This keeps tests consistent and avoids duplicating container boilerplate across test classes.

---

### Why the container is `static`

The container is `static` so it starts **once per JVM**, not once per test class:

- significantly faster test runs
- fewer “port already in use” issues
- reduced flakiness in CI

If you make the container non-static, the test suite will become slower and more failure-prone.

---

### Why we use `@DynamicPropertySource`

We do **not** hardcode a JDBC URL in test configuration.

Testcontainers assigns a random host port at runtime.  
`@DynamicPropertySource` registers the actual connection details generated by the container:

- `spring.datasource.url`
- `spring.datasource.username`
- `spring.datasource.password`

This is the most reliable way to wire Spring Boot to Testcontainers.

---

### Why Flyway is enabled in integration tests

Flyway is enabled so the database schema is created **exactly** as in production:

- migrations are the single source of truth
- tests fail fast if a migration is missing, broken, or out of order

Without Flyway in tests, you can accidentally:

- validate against a stale schema
- rely on Hibernate auto-DDL in tests but not in production
- ship broken migrations that CI never executed

---

## Environment variables: what is used where

This project intentionally separates **runtime configuration** from **test-only configuration**.

### Runtime (Spring standard)

Used for `bootRun`, docker-compose runtime, staging, and production:

- `SPRING_DATASOURCE_URL`
- `SPRING_DATASOURCE_USERNAME`
- `SPRING_DATASOURCE_PASSWORD`
- `SPRING_FLYWAY_ENABLED` (preferred)

These are Spring-native names so Spring Boot can bind them automatically.

---

### Tests (Testcontainers only)

Used **only** by `BaseIntegrationTest` when constructing the container:

- `TEST_DATASOURCE_IMAGE` (default: `postgres:16-alpine`)
- `TEST_DATASOURCE_DB` (default: `pokedex_test`)
- `TEST_DATASOURCE_USER` (default: `test`)
- `TEST_DATASOURCE_PASSWORD` (default: `test`)

These variables do **not** affect runtime configuration.

---

### Why we avoid custom DB env vars

Avoid patterns like `DB_HOST`, `DB_PORT`, `DB_NAME`, and manually assembling JDBC URLs.

This creates drift between:

- local development
- CI
- Docker
- production

Using `SPRING_DATASOURCE_URL` keeps configuration portable and predictable.

---

## Why `ddl-auto=validate` in integration tests

Hibernate DDL is set to `validate` (not `update`, `create`, or `create-drop`).

Reason:

- the schema must come from **Flyway migrations**
- Hibernate should only verify entity-to-schema compatibility

If this is changed to `update` or `create`, you risk:

- tests passing while migrations are broken
- schema drift between environments
- production failures on deploy

---

## Common refactor traps (and why they break CI)

### Trap 1: “Let’s use `application-test.yml` with a fixed JDBC URL”

Fails because Testcontainers uses random ports.  
Hardcoded URLs will break on most machines and in CI.

---

### Trap 2: “Let’s disable Flyway in tests to speed things up”

You will eventually ship a broken migration because tests never ran it.

---

### Trap 3: “Let’s create containers inside each test class”

- much slower test execution
- increased flakiness
- duplicated configuration logic

---

### Trap 4: “Let’s switch integration tests to H2”

You lose PostgreSQL reality.  
If you do this, document the tradeoff explicitly.

---

## How to write tests in this repo

### Integration tests (database-backed)

Use `@SpringBootTest` and extend `BaseIntegrationTest`:

```java
@SpringBootTest
class PokemonRepositoryIT extends BaseIntegrationTest {
  // integration tests
}
```

---

### Slice tests (no database)

Use Spring slice tests when a database is not required:

- `@WebMvcTest` for controllers
- `@JsonTest` for serialization

Slice tests **must not** extend `BaseIntegrationTest`.

---

## Local Docker runtime notes

Testcontainers requires a working Docker runtime.

On macOS, **Colima** is supported and commonly used.  
If Docker is not running, you may see errors such as:

- “Could not find a valid Docker environment”
- failures resolving the Docker socket

See `DOCKER.md` / `COLIMA.md` (if present) for local troubleshooting.

---

## If you change this wiring

If you modify any of the following, update this document and verify both local and CI runs:

- Testcontainers image or version
- Flyway enablement or migration locations
- Hibernate DDL mode
- environment variable naming or loading
- the base integration test structure

The goal is stability:  
**a green test suite must mean the database and migrations are healthy.**
